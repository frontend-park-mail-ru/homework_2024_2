<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: set.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: set.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

/**
 * Регулярные выражения, используемые для обработки пути к свойству объекта.
 * @type {Object}
 * @property {RegExp} PATH - Регулярное выражение для поиска ключей в квадратных скобках.
 * @property {RegExp} INVALID_KEY - Регулярное выражение для проверки некорректных ключей.
 * @property {RegExp} MASSIVE - Регулярное выражение для проверки числовых индексов.
 */
const REGEX_PATTERNS = {
    PATH: /\[(\w+)\]|\["(.+?)"\]/g,
    INVALID_KEY: /\[(-\w+)\]/,
    MASSIVE: /^\d+$/
};

/**
 * Устанавливает значение в указанное свойство объекта, используя путь.
 *
 * @param {Object} obj - Объект, в который нужно установить значение.
 * @param {string} path - Путь к свойству объекта в виде строки.
 * Путь может быть задан в виде 'a.b.c' или 'a[0].b["key"]'.
 * @param {*} value - Значение, которое необходимо установить.
 * @returns {Object} Объект с установленным значением.
 * @throws {Error} Если пытаются обратиться к элементу массива с отрицательным индексом.
 *
 * @example
 * const obj = {};
 * set(obj, 'a.b.c', 42);
 * // obj теперь равно { a: { b: { c: 42 } } }
 *
 * @example
 * const obj = {};
 * set(obj, 'a[0].b["key"]', 'value');
 * // obj теперь равно { a: [ { b: { key: 'value' } } ] }
 */
const set = (obj, path, value) => {
    if (path !== '') {
        const pathArray = path.replace(REGEX_PATTERNS.PATH, '.$1$2').split('.').filter(Boolean);

        let acc = obj;

        let prevKey = 0;

        pathArray.forEach((key, index) => {
            if (index !== 0) {
                if (REGEX_PATTERNS.INVALID_KEY.test(prevKey)) {
                    throw new Error("Addressing an array element with a negative key is invalid");
                }

                acc = acc[prevKey] = (typeof acc[prevKey] !== 'object' || acc[prevKey] === null || !(acc[prevKey] instanceof Object))
                    ? (REGEX_PATTERNS.MASSIVE.test(key) ? [] : {}) : acc[prevKey];
            }

            prevKey = key;
        });

        acc[prevKey] = value;
    }

    return obj;
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#REGEX_PATTERNS">REGEX_PATTERNS</a></li><li><a href="global.html#set">set</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Tue Sep 03 2024 14:11:07 GMT+0300 (Москва, стандартное время)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
